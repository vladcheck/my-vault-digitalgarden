---
{"dg-publish":true,"permalink":"/00-notes/sql/"}
---

SQL (Structured Query Language - структурированный [[Язык запросов\|язык запросов]]) - [[Декларативный подход\|декларативный]] [[00 - Notes/Язык программирования\|Язык программирования]] для взаимодействия с [[00 - Notes/Реляционная база данных\|реляционными]] [[00 - Notes/База данных\|БД]].

>[!links] Интерактивные курсы
>- [SQL Academy](https://sql-academy.org/ru/guide) - самый лучший
>- [SQLBolt - Learn SQL - Introduction to SQL](https://sqlbolt.com/) (подольше)
>- [SQL Teaching - The easiest tutorial to learn SQL](https://www.sqlteaching.com/) (поменьше)

# Синтаксис
>[!tl;dr] [[00 - Notes/Кратко о командах SQL, не зависимых от диалекта\|Кратко о командах SQL, не зависимых от диалекта]]

>[!info] Правила хорошего тона
>1. Каждая команда должна оканчиваться точкой с запятой (;)
>2. Принято писать все ключевые слова транслитом
>3. Принято использовать одинарные кавычки вместо двойных

В общем виде полная команда в SQL выглядит так:
```sql
SELECT DISTINCT column, AGG_FUNC(_column_or_expression_), …
FROM mytable
	JOIN another_table
	ON mytable.column = another_table.column
	WHERE _constraint_expression_
	GROUP BY column
	HAVING _constraint_expression_
	ORDER BY _column_ ASC/DESC
	LIMIT _count_ OFFSET _COUNT_;
```
## Литералы
### Даты, дата и время
Даты пишутся в одинарных кавычках (как и строки). Числа либо разделяются каким-то одним постоянным символов (только тире, пробелом, запятой и т.п.) или пишутся слитно: `'21102025'`.
>[!attention] Дата без указания времени воспринимается как дата с нулевым временем
>```sql
>'21.10.2025' -- > 21.10.2025 00:00:00
>```

| Описание     | Формат                                             | Допустимые виды синтаксиса              | Примечание                                                                                                              |
| ------------ | -------------------------------------------------- | --------------------------------------- | ----------------------------------------------------------------------------------------------------------------------- |
| Дата         | Интерпретируется как дата со временем, равным нулю | `YYYY-MM-DD` и подобные, `YYYYMMDDВ`    | Вместо разделителя "-" можно использовать любой знак препинания.    Например:  `'2020-01-01'` = 1 января 2020, 00:00:00 |
| Время        | Содержит только время без конкретной даты          | `hh:mm:ss`, `hh:mm`, `hh`, `ss`         | Разделитель тоже можно опустить.  Например:  `12:11` = 12:11:00                                                         |
| Дата и время | Дата с возможностью задать конкретное время        | `YYYY-MM-DD hh:mm:ss`, `YYYYMMDDhhmmss` | Например:  `'20200101183030'` = 1 января 2020, 18:30:30                                                                 |
### Строки
#### Поддержка экранирования. E-строки
Для того, чтобы можно было экранировать символы в строковых литералах, в SQL существуют E-строки. Просто нужно перед литералом строки написать `E`:
```sql
SELECT "This string \t is normal!" AS Disclaimer; -- > This string \t is normal!

SELECT E"This string \t is not normal!" AS Disclaimer; -- > This string      is not normal! (\t воспринят как TAB)
```
## Типы данных
| Data type                                            | Размер, [[Байт\|Байт]] | Примечания                                                                        |
| ---------------------------------------------------- | ---------------- | --------------------------------------------------------------------------------- |
| `TINYINT`                                            | 1                | $-2^{7}\leq s<2^{7}$ или $0\leq s<2^{8}$                                          |
| `SMALLINT`                                           | 2                | $-2^{15}\leq s< 2^{15}$ или $0\leq s<2^{16}$                                      |
| `MEDIUMINT`                                          | 3                | $-2^{23}\leq s<2^{23}$ или $0\leq s<2^{24}$                                       |
| `INTEGER`,`INT`                                      | 4                | $-2^{31}\leq s<2^{31}$ или $0\leq s<2^{32}$                                       |
| `BIGINT`                                             | 8                | $-2^{63}\leq s<2^{63}$ или $0\leq s<2^{64}$                                       |
| `BOOLEAN`                                            | 1                | В некоторых разновидностях SQL `BOOLEAN` может быть представлен в виде `0` и `1`. |
| `FLOAT`                                              | 4                |                                                                                   |
| `DOUBLE`                                             | 8                |                                                                                   |
| `REAL`                                               |                  |                                                                                   |
| `CHARACTER(num_chars)`, `VARCHAR(num_chars)`, `TEXT` | Varies           |                                                                                   |
| `DATE`, `DATETIME`                                   |                  |                                                                                   |
| `BLOB`                                               | Varies           | Хранит в себе набор байтов (см. [[Blob\|Blob]])                                         |
## Ограничения
| Constraint           | Description                                                                                                                                             | Пример                                                                    |
| -------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------- |
| `PRIMARY KEY`        | Эти значения уникальны и, следовательно, однозначно идентифицируют каждую строку.                                                                       | `id INT PRIMARY KEY` определяет колонку `id` как `PRIMARY KEY` типа `INT` |
| `AUTOINCREMENT`      | *Не везде поддерживается*. При вставке строки это значение (если оно целочисленное) автоматически увеличивается на `1` при вставке каждой новой строки. |                                                                           |
| `UNIQUE`             | Обязан быть уникальным. Не идентифицируют строку.                                                                                                       |                                                                           |
| `NOT NULL`           | Не может быть `NULL`.                                                                                                                                   |                                                                           |
| `FOREIGN KEY`        | Значение `PRIMARY KEY` из другой таблицы.                                                                                                               |                                                                           |
| `CHECK <expression>` | Значения должны соответствовать кастомному условию.                                                                                                     |                                                                           |
# Действия над таблицами
Мы можем глобально влиять на [[Scheme\|таблицы]]: [[#Создание|создавать]], [[#Удаление|удалять]], [[#Обновление значений|редактировать]], а также фильтровать, сортировать, агрегировать и иным образом обрабатывать выбираемые значения.
## Создание
Для создания таблиц используется выражение `CREATE TABLE IF NOT EXISTS <table> (...);`:
```sql
CREATE TABLE IF NOT EXISTS mytable ( 
	<column_name> <type> ?(<constraint>) ?(DEFAULT _default_value_),
	… 
);
```
- [[CREATE INDEX\|CREATE INDEX]] - 
- [[CREATE VIEW\|CREATE VIEW]] - 
Пример ([[00 - Notes/PostgreSQL\|PostgreSQL]]):
```postgresql
CREATE TABLE IF NOT EXISTS game_character_birthdays (
	id INT PRIMARY KEY,
	name TEXT,
	birthday DATE
);
```
## Редактирование схемы таблицы
`ALTER` позволяет редактировать уже существующую таблицу. Он может:
1) Поменять название: `ALTER TABLE <table> RENAME TO new_table_name`
2) Добавить столбец: `ALTER TABLE <table> ADD <name> <type> ?(<constraint) ?(DEFAULT default_value);`
3) Удалить столбец: `ALTER TABLE <table> DROP <column>;`
В зависимости от разновидности SQL `ALTER` может иметь и другие применения, но эти (по идее) присутствуют везде по умолчанию.
## Выборка значений
Для выборки используется оператор `SELECT <something> FROM <table>;`. Он позволяет выбрать всю таблицу (`*`), или конкретные колонки (`col1, col2, col3...`). Далее, при помощи других операторов, выведенные значения можно отфильтровать, отсортировать и преобразовать.
```sql
-- Пример использования SELECT над произвольной БД
SELECT car, year_of_production FROM car_delearship;
```
## Вставка значений
Нужно использовать оператор `INSERT INTO <table> VALUES <values>`. `PRIMARY KEY` не надо указывать, он добавится автоматически:
```sql
INSERT INTO mytable 
VALUES (value_or_expr, another_value_or_expr, …),
	(value_or_expr_2, another_value_or_expr_2, …), 
	…;
```
Можно указать конкретные столбцы, в которые будет происходить вставка. Это можно указать в списке столбцов `(column, another_column, …)`:
```sql
INSERT INTO mytable
(column, another_column, …)
VALUES ...;
```
## Обновление значений
>[!tip] Как не сломать ничего?
>Предварительно стоит использовать `SELECT`, чтобы проверить, что изменятся нужные колонки. Потом просто заменить его на `UPDATE`.

Нужно использовать оператор `UPDATE <table> SET <column=value> ?(WHERE <condition>)`, который заменит значения в конкретных столбцах *для тех строк, где сработает условие из `WHERE`*:
```sql
UPDATE mytable 
SET column = value_or_expr, other_column = another_value_or_expr, … WHERE condition;
```
## Удаление
>[!tip] Как не сломать ничего?
>Предварительно стоит использовать `SELECT`, чтобы проверить, что изменятся нужные колонки. Потом просто заменить его на `DELETE`.

Чтобы удалить всю таблицу, нужно прописать `DROP TABLE IF EXISTS <table>;`. Чтобы удалить конкретные строки, нужно использовать оператор `DELETE FROM <table> WHERE <condition>`.
# Агрегаторы (функции)
Агрегатор - SQL-функция. Значение функции может быть использована в `WHERE`, `HANDLE` или `SELECT`. Стоит иметь в виду, что агрегатор работает *на колонку данных*:
- Числа
	- `ROW_NUMBER()` - номер ряда
	- `SUM()` - сумма чисел
	- `MAX()` - максимальное значение
	- `MIN()` - минимальное значение
	- `AVG()` - [[00 - Notes/Средняя\|Среднее арифметическое]]
	- `COUNT()` - количество строк
	- `ROUND(<number>,<places>)` - [[округлить\|Округление]] до определенного знака после запятой (по умолчанию до целого числа). *Также можно округлять до запятой (*`ROUND(153, -1) => 150`*)*;
	- `BETWEEN <number> AND <number>` - значения между двумя числами
	- `SUBSTR(<column>,<begin>,<?length>)` - поиск в подстроке. Если не указана длина, ищет от `<begin>` до конца строки;
- Даты
	- `DAY()`
	- `WEEKDAY()`
	- `MONTH()`
	- `YEAR()`
	- `DATE_FORMAT(<expression>,<format_string>)`
- Строки
	- `CONCAT()` - [[Конкатенация\|Конкатенация]] строк;
	- `LENGTH(<string>)` - длина строки;
	- `LEFT(<string>,<index>)` - получить символ строки слева по счету;
- Разное
	- [[00 - Notes/WINDOW functions (SQL)\|WINDOW functions (SQL)]]
	- `COALESCE(<column>,<column>,...)` - принимает несколько столбцов и возвращает значение первого из них, где не будет `NULL` (похоже на [[00 - Notes/Promise API\|promise.race()]]);
	- `CASE <query>` - аналог `if else`:
```sql
SELECT *, CASE WHEN <expression> THEN <expression>   
WHEN <expression> THEN <expression>   
...   
ELSE <expression>
END ?<column_name>
```